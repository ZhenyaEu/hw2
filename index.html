false && true || true  // true - false и true это false (т.к. слева false), false или true это true (возвращается значение справа т.к. слева не true);

false && (true || true);  // false - true или true в скобках будет true т.к. это короткое замыкание (true слева от оператора "или"), дающее true , false и true будет false т.к. это короткое замыкание (false слева от оператора "и") дающее false;

+'40' + +'2';  // 42 - унарный плюс, перед строчным типом данных, преобразует тип данных в числовой 40+2=42;

'2' + 3 ** 2;  // 29 - 3 в квадрате = 9, строчный тип 2 + числовой 9 -> строчный 29 (произошла конкатенация т.е. если хотя бы один аргумент бинарного плюса является строкой, то второй тоже преобразуется к строке (это касается только бинарного плюса));

3 ** 2 / 3;  // 3 - 3 в квадрате = 9, 9/3=3;

3 ** (9 / 3);  // 27 - 9/3=3, 3 в кубе = 27;

'10' + (5 === 6);  //10false -  5 не равно строго 6 -> false, строчный тип 10 и false -> конкатенация;

'10' - 5 === 6;  // false - строчная 10 преобразуется в число т.к. справа не плюс, таким образом 10-5=5, 5 не равно 6;

undefined + 1;   //NaN - невозможная математическая операция так как значение слева не определено;

(+null == false) < 1;  //false - +null (+ приводит null к числу т.е. 0) равен false т.е. 0 -> результат сравнения будет true т.е. 1, что не меньше единицы; 

(+null == false) < 1 ** 5;  //false - +null (+ приводит null к числу т.е. 0) равен false т.е. 0 -> результат сравнения будет true т.е. 1, что не меньше единицы в пятой степени (1);

var number = 5;
2 * ++number; 
2 * number--; 
console.log(number);  //5 - вторая строка - префиксный инкремент -> 6
третья строка - постфиксный декремент уменьшает number на 1 -> 5
инкремент/декремент применены к переменной number,
а математические выражения 2 * ++number и 2 * number-- "не работают" так как не выделена область памяти для данных, которые будут результатом этих выражений т.е. не присвоена переменная.